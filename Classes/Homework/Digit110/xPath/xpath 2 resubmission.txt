	What XPath returns all the values of the @type attribute on the <occupation> elements?
-//occupation/@type = 1855 item
	Let's see if we can read that list of occupation @type values without duplicates. Apply the distinct-values() function to your XPath, and record your expression.
-//occupation/@type => distinct-values() = 15 items
	Now let’s chain two functions together! How can you return a count() of those distinct-values()? Record your XPath expression.
-//occupation/@type => distinct-values() => count() =15
	We can write XPath to identify people (pull records of <person> elements) based on their nested <occupation> elements and the attributes marked on those elements. You will need to write XPath expressions with predicates, and sometimes nested predicates to answer the following questions:
		Let’s first find all the occupations marked with the attribute name-value pair: type="artist". Write an XPath expression that returns all the <occupation type="artist">.
-//occupation[@type="artist"] = 66 items
		Now, let’s find the full listings of the artists themselves: How would you return the <person> elements that contain nested <occupation type="artist"> markup?
-//person[occupation[@type="artist"]] =41 items or /person[occupation[@type="artist"]]/persName[1] =41
		Who are the women artists listed in our site index? The @sex attribute on the <person> records "m", "f", or "u" recording conventional gender associations of the nineteenth century for male, female, or undetermined. Write an XPath expression that returns <person> elements when the @sex value is "f" and the nested <occupation> is the @type value of "artist".
-//person[@sex="f"]=327
-//person[@sex="f"][occupation[@type="artist"]] = 4 item
		The @subtype attribute on the <occupation> element holds more specific occupation information. Write an XPath expression that finds all of the <person> elements with an occupation @subtype of "engraver".
-//person[occupation[@subtype="engraver"]] comment= this is your code to look for Female and i get an error code saying "XPath failed due to: The context item for axis step root/descendent::person is absent."
		Study how the birth and death dates are stored in the person entries. Sometimes when the specific birth or death date is unknown, we have simply encoded a year value. Build on your previous XPath expression to locate the one person in the site index who was an engraver born in the year 1787. Who was it?
-//person[occupation[@subtype="engraver"]and birth/@when="1787"]= 1 item
		What XPath would return the birth dates of all the persons with occupation @subtype of "engraver" in the file?
-//person[occupation[@subtype="engraver"]]/birth/@* = 8 items
		Use the simple map ! operator to return the string value of the birth dates you located. Now, send all those dates through the XPath sort() function to sort them from earliest to latest. And let's add one more function to the chain: What happens when you add min() to the end? What is the earliest year in which an engraver listed in our file was born?
-//person[occupation[@subtype="engraver"]]/birth/@*! string() = 8 items
	Explain why the following two XPath expressions return different results. Run each XPath expression, review the results, and explain what you think each expression is returning.
		//person/occupation[1]= 749 items
-This one shows more then just one item with a bunch of subtyoes and types
		(//person/occupation)[1]= 1 item
-and this one just shows one and scholar which might be the only one that is said the most.
